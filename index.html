<!DOCTYPE html>
<html lang="ca">
<head>
    <meta charset="UTF-8">
    <title>LA NOVATA DE L'ANY</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #0a0b10;
            --panel-bg: rgba(16, 20, 35, 0.95);
            --neon-primary: #00f3ff; 
            --neon-secondary: #0aff68;
            --text-main: #d1d5db;
            --glass: blur(10px);
        }

        /* TEMES PER FESTA */
        body.theme-0 { --bg-color: #0a0b10; --neon-primary: #00f3ff; --neon-secondary: #0aff68; } 
        body.theme-1 { --bg-color: #1a0505; --neon-primary: #ff2a2a; --neon-secondary: #2ecc71; } 
        body.theme-2 { --bg-color: #1a0a1a; --neon-primary: #ff00cc; --neon-secondary: #f1c40f; } 
        body.theme-3 { --bg-color: #000000; --neon-primary: #ffd700; --neon-secondary: #ffffff; } 
        body.theme-4 { --bg-color: #001a1a; --neon-primary: #00ffff; --neon-secondary: #ff69b4; } 

        * { box-sizing: border-box; }
        body {
            margin: 0; padding: 0; background-color: var(--bg-color); color: var(--text-main);
            font-family: 'Roboto Mono', monospace; overflow: hidden; height: 100vh;
            display: grid; grid-template-columns: 250px 1fr 250px; grid-template-rows: 80px 1fr 160px;
            transition: background-color 1.5s ease;
        }

        /* CAPÃ‡ALERA */
        header {
            grid-column: 1 / -1; background: linear-gradient(180deg, rgba(0,0,0,0.9), transparent);
            border-bottom: 1px solid var(--neon-primary); display: flex; justify-content: space-between; align-items: center;
            padding: 0 20px; z-index: 20; transition: border-color 1.5s;
        }
        h1 { font-family: 'Orbitron'; color: var(--neon-primary); margin: 0; text-shadow: 0 0 10px var(--neon-primary); font-size: 1.2rem; }
        #turn-indicator {
            flex-grow: 1; text-align: center; font-family: 'Orbitron'; font-weight: 900;
            font-size: 2rem; text-transform: uppercase; letter-spacing: 3px; animation: pulse 2s infinite;
        }
        @keyframes pulse { 0% { opacity: 0.8; } 50% { opacity: 1; transform: scale(1.02); } 100% { opacity: 0.8; } }

        /* PANELLS */
        .panel {
            background: var(--panel-bg); backdrop-filter: var(--glass); display: flex; flex-direction: column;
            padding: 10px; overflow-y: auto; border: 0 solid #333; transition: background 1.5s;
        }
        #left-panel { grid-row: 2 / 3; border-right-width: 1px; }
        #right-panel { grid-row: 2 / 3; border-left-width: 1px; }
        
        #game-container { grid-row: 2 / 3; grid-column: 2 / 3; position: relative; overflow: hidden; cursor: grab; }
        #game-container:active { cursor: grabbing; }
        canvas { display: block; width: 100%; height: 100%; }

        /* CONTROLS & DECK */
        #cam-controls { position: absolute; bottom: 20px; right: 20px; display: flex; gap: 5px; z-index: 30; }
        .cam-btn {
            background: rgba(0,0,0,0.8); border: 1px solid var(--neon-primary); color: var(--neon-primary);
            width: 30px; height: 30px; cursor: pointer; display: flex; justify-content: center; align-items: center;
        }
        #control-deck {
            grid-row: 3 / 4; grid-column: 1 / -1; background: #050505; border-top: 2px solid var(--neon-secondary);
            display: flex; align-items: center; justify-content: center; padding: 10px 40px; z-index: 20;
        }
        #calc-container {
            display: flex; flex-direction: column; font-size: 0.75rem; color: #888; 
            margin-right: 20px; padding-right: 20px; border-right: 1px solid #333; text-align: right; min-width: 140px;
        }
        .calc-row { display: flex; justify-content: space-between; gap: 15px; }
        .calc-val { font-weight: bold; color: var(--text-main); }
        .calc-val.pos { color: var(--neon-secondary); }
        .calc-val.neg { color: #ff0055; }

        /* UI ELEMENTS */
        .card {
            background: rgba(255,255,255,0.05); border-left: 3px solid #444; margin-bottom: 8px; padding: 8px; font-size: 0.85rem; transition: 0.3s;
        }
        .card.active { border-left-color: var(--neon-primary); background: rgba(255, 255, 255, 0.15); transform: translateX(5px); }
        .btn {
            background: transparent; border: 1px solid var(--text-main); color: var(--text-main);
            padding: 10px 20px; font-family: 'Orbitron'; cursor: pointer; transition: 0.2s;
        }
        .btn:hover { background: rgba(255,255,255,0.1); }
        .btn:disabled { opacity: 0.3; cursor: not-allowed; filter: grayscale(1); pointer-events: none; }
        .btn-primary { border-color: var(--neon-secondary); color: var(--neon-secondary); box-shadow: 0 0 5px var(--neon-secondary); }
        .btn-primary:hover { background: var(--neon-secondary); color: #000; }
        
        #lang-btn { 
            z-index: 100; font-size: 0.8rem; padding: 5px 10px; margin-left: 15px;
        }

        #prob-disp { font-size: 2.5rem; font-weight: bold; color: var(--neon-secondary); margin: 0 20px; width: 120px; text-align: right; }

        /* OVERLAYS */
        #transition-overlay {
            position: fixed; top:0; left:0; width:100%; height:100%; background: #000; z-index: 200;
            display: flex; justify-content: center; align-items: center; pointer-events: none; opacity: 0; transition: opacity 1s;
        }
        #trans-text {
            font-family: 'Orbitron'; font-size: 4rem; color: transparent; -webkit-text-stroke: 2px var(--neon-primary);
            text-shadow: 0 0 30px var(--neon-primary); text-align: center;
        }
        #setup-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 300;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
        }
        input { background: #222; border: 1px solid #555; color: white; padding: 10px; width: 600px; margin: 10px; font-family: 'Roboto Mono'; text-align: center; }

        /* DRAMA OVERLAY */
        #drama-overlay {
            position: fixed; top:0; left:0; width:100%; height:100%; background: rgba(0,0,0,0.98); z-index: 250;
            display: none; flex-direction: column; justify-content: center; align-items: center;
        }
        #drama-content { display: flex; flex-direction: column; align-items: center; width: 100%; }
        #drama-flavor { font-family: 'Orbitron'; font-size: 1.5rem; color: #aaa; margin-bottom: 20px; font-style: italic; text-transform: uppercase; }
        #drama-versus { font-family: 'Orbitron'; font-size: 2rem; color: var(--neon-primary); margin-bottom: 30px; text-shadow: 0 0 10px var(--neon-primary); }
        #drama-loader-container { width: 60%; height: 8px; background: #222; border-radius: 4px; overflow: hidden; margin-top: 20px; box-shadow: 0 0 10px #222; }
        #drama-loader-bar { height: 100%; width: 0%; background: var(--neon-secondary); box-shadow: 0 0 15px var(--neon-secondary); transition: width 0.05s linear; }
        #drama-result-text {
            font-family: 'Orbitron'; font-size: 8rem; font-weight: 900; opacity: 0; transform: scale(0); transition: 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            position: absolute; z-index: 260; -webkit-text-stroke: 3px black; pointer-events: none; text-align: center;
        }

        /* CREDITS OVERLAY */
        #credits-overlay {
            position: fixed; top:0; left:0; width:100%; height:100%; background: #000; z-index: 400; display: none;
            flex-direction: column; align-items: center; overflow: hidden;
        }
        #credits-content { text-align: center; position: absolute; width: 100%; animation: scrollUp 15s linear forwards; top: 100%; }
        @keyframes scrollUp { to { top: -100%; } }
        .credit-role { font-size: 1rem; color: #888; margin-top: 20px; font-family: 'Orbitron'; }
        .credit-name { font-size: 2rem; color: #fff; margin-bottom: 10px; }
        #winner-display {
            display: none; flex-direction: column; align-items: center; justify-content: center; height: 100%; z-index: 410;
            background: radial-gradient(circle, #222 0%, #000 80%); width: 100%;
        }
        .winner-title { font-size: 3rem; color: var(--neon-secondary); font-family: 'Orbitron'; margin-bottom: 20px; }
        .winner-name { font-size: 6rem; color: #fff; font-family: 'Orbitron'; font-weight: bold; text-shadow: 0 0 50px var(--neon-primary); animation: pulse 1s infinite alternate; }

    </style>
</head>
<body class="theme-0">

    <header>
        <div>
            <h1 id="title-main">/// LA NOVATA DE L'ANY</h1>
            <div id="party-title" style="font-size:0.7rem; color:var(--neon-secondary)">SISTEMA INICIALITZAT</div>
        </div>
        
        <div id="turn-indicator">SETUP</div>
        
        <div style="display:flex; align-items:center; text-align:right">
            <div>
                <div id="label-chaos-bar" style="font-size:0.7rem; color:#888">NIVELL DE CAOS</div>
                <div style="width:100px; height:4px; background:#333; margin-left:auto">
                    <div id="chaos-bar" style="height:100%; width:0%; background:var(--neon-secondary); transition:1s"></div>
                </div>
            </div>
            <button id="lang-btn" class="btn" onclick="game.toggleLanguage()">EN / CA</button>
        </div>
    </header>

    <div id="left-panel" class="panel">
        <div id="player-list"></div>
    </div>

    <div id="game-container">
        <canvas id="graphCanvas"></canvas>
        <div id="cam-controls">
            <div class="cam-btn" onclick="game.camera.zoomIn()">+</div>
            <div class="cam-btn" onclick="game.camera.reset()">R</div>
            <div class="cam-btn" onclick="game.camera.zoomOut()">-</div>
        </div>
        <div id="notification" style="position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);font-family:'Orbitron';font-size:3rem;color:#fff;opacity:0;pointer-events:none;transition:0.3s;text-shadow:0 0 20px white;z-index:50;text-align:center;width:80%"></div>
    </div>

    <div id="right-panel" class="panel">
        <h3 id="label-queue" style="color:var(--neon-secondary);margin-top:0">CUA</h3>
        <div id="queue-list" style="font-size:0.8rem"></div>
        <div id="log" style="margin-top:20px;font-size:0.7rem;color:#888;height:150px;overflow:hidden"></div>
    </div>

    <div id="control-deck">
        <div id="msg-idle" style="color:#555">ESPERANT INPUT...</div>
        
        <div id="action-panel" style="display:none; width:100%; align-items:center; justify-content:space-between;">
            <div style="flex:1">
                <div style="font-family:'Orbitron'; font-size:1.2rem; color:var(--neon-primary)"><span id="label-target">OBJECTIU</span>: <span id="target-name">CAP</span></div>
                <div id="target-sub" style="font-size:0.8rem; color:#888">...</div>
            </div>

            <div id="calc-container">
                <div class="calc-row"><span id="lbl-base">BASE</span><span id="c-base" class="calc-val">--</span></div>
                <div class="calc-row"><span id="lbl-diff">DIF</span><span id="c-diff" class="calc-val neg">--</span></div>
                <div class="calc-row"><span id="lbl-chaos">CAOS</span><span id="c-chaos" class="calc-val pos">--</span></div>
                <div class="calc-row"><span id="lbl-boost">BOOST</span><span id="c-boost" class="calc-val pos">--</span></div>
            </div>
            
            <div style="display:flex; gap:10px">
                <button class="btn" id="btn-beer" onclick="game.buyBoost('beer')">CERVESA â‚¬2</button>
                <button class="btn" id="btn-shot" onclick="game.buyBoost('shot')">XUPITO â‚¬5</button>
            </div>

            <div id="prob-disp">0%</div>

            <div style="display:flex; gap:10px">
                <button class="btn" id="btn-pass" onclick="game.passTurn()">PASSAR</button>
                <button class="btn btn-primary" id="btn-roll" onclick="game.startSequence()">TIRAR LA CANYA</button>
            </div>
        </div>
    </div>

    <div id="transition-overlay"><h1 id="trans-text">FESTA</h1></div>
    
    <div id="drama-overlay">
        <div id="drama-content">
            <div id="drama-versus"></div>
            <div id="drama-flavor">CALCULANT...</div>
            <div id="drama-loader-container"><div id="drama-loader-bar"></div></div>
        </div>
        <div id="drama-result-text">ÃˆXIT</div>
    </div>

    <div id="credits-overlay">
        <div id="credits-content"></div>
        <div id="winner-display">
            <div class="winner-title" id="winner-title-text">LA NOVATA DE L'ANY</div>
            <div class="winner-name" id="winner-name">NOM</div>
            <div id="saving-text" style="margin-top:20px; font-size:0.8rem; color:#888">Graf guardat com a imatge...</div>
        </div>
    </div>

    <div id="setup-overlay">
        <h1 id="setup-title" style="color:var(--neon-primary); font-family:'Orbitron'">CONFIGURACIÃ“ INICIAL</h1>
        <p id="setup-desc">Introdueix els noms dels jugadors:</p>
        <input type="text" id="player-names" value="Ari, Elia, Gaia, Marcel, Dani, Patri, Marta, Diana">
        <button id="setup-btn" class="btn btn-primary" onclick="game.initGame()">INICIAR SIMULACIÃ“</button>
    </div>

<script>
// --- IDIOMES ---
const TEXTS = {
    'ca': {
        title: "/// LA NOVATA DE L'ANY",
        setup_title: "CONFIGURACIÃ“ INICIAL",
        setup_desc: "Introdueix els noms dels jugadors:",
        setup_btn: "INICIAR SIMULACIÃ“",
        sys_init: "SISTEMA INICIALITZAT",
        protocol: "PROTOCOL",
        chaos_level: "NIVELL DE CAOS",
        drunk_level: "BORRATXERA",
        queue: "CUA",
        waiting: "ESPERANT INPUT...",
        target: "OBJECTIU",
        select_node: "SELECCIONA NODE",
        click_interact: "Clica algÃº per interactuar",
        base: "BASE",
        diff: "DIF",
        chaos: "CAOS",
        boost: "BOOST",
        beer: "CERVESA â‚¬2",
        shot: "XUPITO â‚¬5",
        pass: "PASSAR",
        roll: "TIRAR LA CANYA",
        success: "ÃˆXIT",
        rejected: "REBUTJAT",
        calculating: "CALCULANT...",
        winner_title: "LA NOVATA DE L'ANY",
        saving: "Graf guardat com a imatge...",
        streak: "RATXA ACTUAL",
        cost_turn: "Cost: 1 Torn",
        steal_from: "ROBAR DE",
        first_move: "PRIMER MOVIMENT: Garantit",
        notify_prof: "ELS PROFESSORS HAN ARRIBAT",
        notify_gold: "DISFRESSES LLEGENDÃ€RIES!",
        notify_vip: "ZONA VIP OBERTA!",
        notify_win_bonus: "GUANYA EL BONUS x1.5!",
        notify_hype: "GUANYA HYPE (+5 Pts)!",
        notify_no_solo: "NO POTS DEIXAR-LO SOL!",
        notify_prof_rej: "ELS PROFES NOMÃ‰S PARLEN AMB ELS PRINGATS!",
        notify_too_far: "MASSA LLUNY (Dist > 3)",
        notify_deg1: "HAN DE SER SOLITARIS (Grau 1)",
        notify_owned: "JA EL TENS!",
        log_conn: "connecta amb",
        log_rej: "ha sigut rebutjat per",
        log_pass: "passa.",
        mode_time: "MODE CONTRARRELLOTGE",
        parties: ["FESTA DE NOVATOS", "FESTA DE NADAL", "FESTA DE CARNAVAL", "FMESTA GRAN", "FESTA HAWAIIANA"],
        phrases: ["Trencant el gel...", "Demanant 'Despacito'...", "Ballant el robot...", "Fent contacte visual...", "Arreglant-se el cabell...", "Comprant una copa...", "Fent finger guns...", "Buscant encenedor...", "Cha Cha Real Smooth...", "Fent-se l'interessant...", "Mirada de tigre...", "Sortint a fumar..."],
        rank: "POSICIÃ“"
    },
    'en': {
        title: "/// ROOKIE OF THE YEAR",
        setup_title: "INITIAL SETUP",
        setup_desc: "Enter player names:",
        setup_btn: "LAUNCH SIMULATION",
        sys_init: "SYSTEM INITIALIZED",
        protocol: "PROTOCOL",
        chaos_level: "CHAOS LEVEL",
        drunk_level: "DRUNKENNESS",
        queue: "QUEUE",
        waiting: "WAITING FOR INPUT...",
        target: "TARGET",
        select_node: "SELECT NODE",
        click_interact: "Click someone to interact",
        base: "BASE",
        diff: "DIFF",
        chaos: "CHAOS",
        boost: "BOOST",
        beer: "BEER â‚¬2",
        shot: "SHOT â‚¬5",
        pass: "PASS",
        roll: "MAKE A MOVE",
        success: "SUCCESS",
        rejected: "REJECTED",
        calculating: "CALCULATING...",
        winner_title: "ROOKIE OF THE YEAR",
        saving: "Graph saved as image...",
        streak: "CURRENT STREAK",
        cost_turn: "Cost: 1 Turn",
        steal_from: "STEAL FROM",
        first_move: "FIRST MOVE: Guaranteed",
        notify_prof: "PROFESSORS HAVE ARRIVED",
        notify_gold: "LEGENDARY COSTUMES!",
        notify_vip: "VIP AREA OPEN!",
        notify_win_bonus: "WINS THE x1.5 BONUS!",
        notify_hype: "GAINS HYPE (+5 Pts)!",
        notify_no_solo: "CAN'T LEAVE THEM ALONE!",
        notify_prof_rej: "PROFS ONLY TALK TO UNDERDOGS!",
        notify_too_far: "TOO FAR (Dist > 3)",
        notify_deg1: "MUST BE LONERS (Deg 1)",
        notify_owned: "ALREADY YOURS!",
        log_conn: "connected with",
        log_rej: "was rejected by",
        log_pass: "passes.",
        mode_time: "TIME TRIAL MODE",
        parties: ["FRESHMAN PARTY", "CHRISTMAS PARTY", "CARNIVAL PARTY", "BIG FMESTA", "HAWAIIAN PARTY"],
        phrases: ["Breaking the ice...", "Requesting 'Despacito'...", "Doing the Robot...", "Making eye contact...", "Fixing hair...", "Buying a drink...", "Finger guns...", "Looking for a light...", "Cha Cha Real Smooth...", "Acting cool...", "Tiger eyes...", "Going for a smoke..."],
        rank: "RANK"
    }
};

const CONFIG = {
    budgetStart: 40, 
    maxTurnsPerParty: 3,
    students: ["Cabanes", "Alexi", "Novak", "Nora", "RaÃ¼l", "Albert", "Ferran", "Paco", "Ciscu", "Laure", "Alex", "Manyer", "Deivid", "MaÃ§Ã³", "Cospi", "Francesc", "Jordi", "Mireia", "Laia", "Pol", "Guim", "Aina", "MartÃ­", "Quim", "Ona", "Biel", "Montserrat", "Sergi", "NÃºria", "Xavi", "Berta", "Julia", "Roger", "Carla", "Anna"],
    professors: ["Roura", "Miliki", "Casanellas", "Tyrion"],
    celebrities: ["Shakira", "Bad Bunny", "Rosalia", "Messi", "Nadal", "Alcaraz", "Aitana", "Ibai", "Quevedo", "Karol G"],
    parties: [ 
        { id: 0 }, { id: 1 }, { id: 2 }, { id: 3 }, { id: 4 }
    ]
};

class Player {
    constructor(id, name, color) {
        this.id=id; this.name=name; this.color=color; this.score=0; this.budget=CONFIG.budgetStart;
        this.nodeId=null; this.turnsThisParty=0; this.hasGrant=false; 
        this.fixedPoints = 0;
        this.fmeMultiplier = 1.0;
        this.savedBudget = 0;
        this.drunkenness = 0;
        this.streak = 0;
    }
}
class Node {
    constructor(id, name, type, x, y) {
        this.id=id; this.name=name; this.type=type; this.x=x; this.y=y; this.vx=0; this.vy=0;
        this.radius = type==='player' ? 15 : (type==='prof'?20:10);
        if(type === 'prof') {
            this.coolness = 50;
        } else {
            const r1 = Math.random(); const r2 = Math.random();
            this.coolness = Math.floor((r1 + r2) * 7) + 5;
        }
        this.isGolden = false; this.isTemporary = false; this.hidden = false; 
    }
}
class Edge { constructor(s, t, o=null) { this.source=s; this.target=t; this.owner=o; this.hidden = false; } }

const game = {
    canvas: document.getElementById('graphCanvas'), ctx: document.getElementById('graphCanvas').getContext('2d'),
    nodes: [], edges: [], players: [], queue: [], partyIndex: 0, chaos: 0, currentPlayer: null, targetNode: null, currentBoost: 0,
    width: 0, height: 0, cliques: [], camera: { x: 0, y: 0, zoom: 1, isDragging: false, lastX: 0, lastY: 0 },
    processing: false, isFMEstaMode: false, fmestaScores: {},
    lang: 'ca',

    // --- I18N FUNCTIONS ---
    toggleLanguage() {
        this.lang = (this.lang === 'ca') ? 'en' : 'ca';
        this.updateTexts();
    },
    t(key) { return TEXTS[this.lang][key] || key; },
    updateTexts() {
        const T = TEXTS[this.lang];
        document.getElementById('title-main').innerText = T.title;
        document.getElementById('setup-title').innerText = T.setup_title;
        document.getElementById('setup-desc').innerText = T.setup_desc;
        document.getElementById('setup-btn').innerText = T.setup_btn;
        document.getElementById('label-queue').innerText = T.queue;
        document.getElementById('label-target').innerText = T.target;
        document.getElementById('lbl-base').innerText = T.base;
        document.getElementById('lbl-diff').innerText = T.diff;
        document.getElementById('lbl-chaos').innerText = this.isFMEstaMode ? T.drunk_level : T.chaos;
        document.getElementById('label-chaos-bar').innerText = this.isFMEstaMode ? T.drunk_level : T.chaos_level;
        document.getElementById('lbl-boost').innerText = T.boost;
        document.getElementById('btn-beer').innerText = T.beer;
        document.getElementById('btn-shot').innerText = T.shot;
        document.getElementById('btn-pass').innerText = T.pass;
        document.getElementById('btn-roll').innerText = T.roll;
        document.getElementById('drama-flavor').innerText = T.calculating;
        document.getElementById('winner-title-text').innerText = T.winner_title;
        document.getElementById('saving-text').innerText = T.saving;
        
        // Update dynamic content if game running
        if(this.partyIndex !== undefined) {
             document.getElementById('party-title').innerText = `${T.sys_init} - ${T.protocol}: ${T.parties[this.partyIndex]}`;
             document.getElementById('trans-text').innerText = T.parties[this.partyIndex];
        }
        if(!this.currentPlayer) document.getElementById('msg-idle').innerText = T.waiting;
        else this.updateControlDeck(); // Refresh deck texts
        this.updateUI(); // Refresh Queue texts
    },

    initGame() {
        const names = document.getElementById('player-names').value.split(',').map(s => s.trim()).filter(s => s);
        const colors = ['#ff0055', '#00ccff', '#ccff00', '#aa00ff', '#ffaa00', '#00ffaa', '#ffffff', '#ff00cc'];
        this.resize();
        this.players = names.map((n, i) => new Player(i, n, colors[i % colors.length]));
        this.initGraph();
        document.getElementById('setup-overlay').style.display = 'none';
        this.startParty(0);
        this.loop();
        this.camera.zoomIn = () => this.camera.zoom *= 1.1;
        this.camera.zoomOut = () => this.camera.zoom /= 1.1;
        this.camera.reset = () => { this.camera.x=0; this.camera.y=0; this.camera.zoom=1; };
        this.updateTexts();
    },
    initGraph() {
        this.players.forEach((p, i) => {
            const angle = (i/this.players.length)*Math.PI*2;
            const n = new Node(this.nodes.length, p.name, 'player', Math.cos(angle)*350, Math.sin(angle)*350);
            p.nodeId = n.id; this.nodes.push(n);
        });
        CONFIG.students.forEach(name => this.nodes.push(new Node(this.nodes.length, name, 'student', (Math.random()-0.5)*500, (Math.random()-0.5)*400)));
        const students = this.nodes.filter(n => n.type === 'student');
        for(let i=0; i<students.length/2; i++) { for(let j=i+1; j<students.length/2; j++) { if (Math.random() < 0.2) this.edges.push(new Edge(students[i].id, students[j].id)); } }
        for(let i=Math.floor(students.length/2); i<students.length; i++) {
            const target = students[Math.floor(Math.random() * (students.length/2))];
            this.edges.push(new Edge(students[i].id, target.id));
        }
    },
    startParty(index) {
        this.partyIndex = index; this.chaos = 0;
        this.isFMEstaMode = (index === 3);
        document.body.className = `theme-${index}`;
        
        this.updateTexts(); // Refresh party title
        const ov = document.getElementById('transition-overlay');
        ov.style.opacity = 1; setTimeout(() => ov.style.opacity = 0, 2500);

        if(index > 0 && index !== 3) this.players.forEach(p => p.budget += 5);
        this.nodes.forEach(n => n.isGolden = false);

        if(index === 1) { // NADAL
             CONFIG.professors.forEach(n => this.nodes.push(new Node(this.nodes.length, n, 'prof', 0, 0)));
             this.notify(this.t('notify_prof'), "red");
        }

        if(index === 2 || index === 4) { // CARNAVAL i HAWAIIANA
            this.assignGoldenNodes();
        }

        if(index === 3) { // FMESTA GRAN
            this.startFMEstaMode();
        }

        this.players.forEach(p => {
            p.turnsThisParty = 0; p.drunkenness = 0; p.streak = 0;
        });

        let sorted = [...this.players];
        if (index === 3) sorted.sort(() => Math.random() - 0.5);
        else if(index > 0) sorted.sort((a, b) => b.score - a.score);
        else sorted.sort(() => Math.random() - 0.5);
        
        this.queue = sorted.map(p => p.id);
        this.detectCliques(); this.updateUI(); this.nextTurn();
    },

    assignGoldenNodes() {
        const students = this.nodes.filter(n => n.type === 'student');
        if(students.length >= 2) {
            const shuffled = students.sort(() => 0.5 - Math.random());
            shuffled[0].isGolden = true; shuffled[1].isGolden = true;
            this.notify(this.t('notify_gold'), "gold");
        }
    },

    startFMEstaMode() {
        this.notify(this.t('notify_vip'), "#fff");
        this.fmestaScores = {};
        this.players.forEach(p => {
            this.fmestaScores[p.id] = 0;
            p.savedBudget = p.budget; p.budget = 20;
        });
        this.nodes.forEach(n => { if(n.type !== 'player') n.hidden = true; });
        this.edges.forEach(e => e.hidden = true);

        // --- NEW: ONLY 10 NODES WITH FAMOUS NAMES ---
        for(let i=0; i<CONFIG.celebrities.length; i++) {
            const n = new Node(this.nodes.length, CONFIG.celebrities[i], 'student', (Math.random()-0.5)*600, (Math.random()-0.5)*500);
            n.isTemporary = true;
            n.coolness = 25; // High base coolness
            this.nodes.push(n);
        }
        
        document.getElementById('lbl-chaos').innerText = this.t('drunk_level');
        document.getElementById('label-chaos-bar').innerText = this.t('drunk_level');
    },

    endFMEstaMode() {
        this.players.forEach(p => p.budget = p.savedBudget + Math.floor(p.budget/2));
        let max = -1; let winnerId = null;
        this.players.forEach(p => {
            if(this.fmestaScores[p.id] > max) { max = this.fmestaScores[p.id]; winnerId = p.id; }
        });
        if(winnerId !== null) {
            const w = this.players.find(p => p.id === winnerId);
            w.fmeMultiplier = 1.5;
            this.notify(`${w.name} ${this.t('notify_win_bonus')}`, 'var(--neon-primary)');
        }
        this.nodes = this.nodes.filter(n => !n.isTemporary);
        this.edges = this.edges.filter(e => {
            if(!e.source || !e.target) return false;
            const t = this.nodes.find(n => n.id === e.target);
            const s = this.nodes.find(n => n.id === e.source);
            return t && s; 
        });
        this.nodes.forEach(n => n.hidden = false);
        this.edges.forEach(e => e.hidden = false);
        document.getElementById('lbl-chaos').innerText = this.t('chaos');
        document.getElementById('label-chaos-bar').innerText = this.t('chaos_level');
        this.isFMEstaMode = false;
    },

    nextTurn() {
        this.processing = false;
        if (this.isFMEstaMode) {
            if (this.queue.length === 0) { this.endParty(); return; }
            const pid = this.queue[0]; 
            this.currentPlayer = this.players.find(p => p.id === pid);
        } else {
            this.queue = this.queue.filter(pid => this.players.find(pl => pl.id === pid).turnsThisParty < CONFIG.maxTurnsPerParty);
            if (this.queue.length === 0) { this.endParty(); return; }
            const pid = this.queue.shift();
            this.currentPlayer = this.players.find(p => p.id === pid);
            const isFirstRoundNovatos = (this.partyIndex === 0 && this.edges.filter(e => e.owner).length < this.players.length);
            if (!isFirstRoundNovatos) this.chaos = Math.min(100, this.chaos + 5);
        }
        
        this.currentBoost = 0; this.targetNode = null;
        const banner = document.getElementById('turn-indicator');
        banner.innerText = `${this.currentPlayer.name}`; banner.style.color = this.currentPlayer.color;
        banner.style.textShadow = `0 0 25px ${this.currentPlayer.color}`;
        document.getElementById('msg-idle').style.display = 'none';
        document.getElementById('action-panel').style.display = 'flex';
        document.getElementById('target-name').innerText = this.t('select_node');
        
        let subtitle = this.t('click_interact');
        if(this.isFMEstaMode) subtitle = `${this.t('streak')}: ${this.currentPlayer.streak}`;
        document.getElementById('target-sub').innerText = subtitle;
        document.getElementById('prob-disp').innerText = "--";
        document.getElementById('btn-roll').disabled = true;
        document.getElementById('btn-pass').disabled = false;
        document.getElementById('btn-beer').disabled = false;
        document.getElementById('btn-shot').disabled = false;
        document.querySelectorAll('.calc-val').forEach(el => el.innerText = "--");
        this.updateUI();
    },

    getMainComponent() {
        if (this.nodes.length === 0) return new Set();
        let visited = new Set(); let components = [];
        for(let n of this.nodes) {
            if (n.type !== 'player' && n.type !== 'prof' && n.type !== 'student') continue;
            if (n.hidden) continue;
            if (!visited.has(n.id)) {
                let q = [n.id]; let comp = new Set();
                visited.add(n.id); comp.add(n.id);
                while(q.length > 0) {
                    let curr = q.shift();
                    this.edges.forEach(e => {
                        if(e.hidden) return;
                        let neighbor = null;
                        if(e.source === curr) neighbor = e.target;
                        else if(e.target === curr) neighbor = e.source;
                        if(neighbor !== null && !visited.has(neighbor)) { visited.add(neighbor); comp.add(neighbor); q.push(neighbor); }
                    });
                }
                components.push(comp);
            }
        }
        if (components.length === 0) return new Set();
        components.sort((a,b) => b.size - a.size);
        return components[0];
    },

    handleInput(x, y) {
        if (!this.currentPlayer || this.processing) return;
        const wx = (x - this.width/2) / this.camera.zoom + this.camera.x;
        const wy = (y - this.height/2) / this.camera.zoom + this.camera.y;
        const hitRadius = 20 / this.camera.zoom;
        const clicked = this.nodes.find(n => (n.x-wx)**2 + (n.y-wy)**2 < (n.radius + hitRadius)**2);

        if (clicked && clicked.type !== 'player' && !clicked.hidden) {
            if (this.isFMEstaMode) {
                if (!clicked.isTemporary) return;
                const alreadyMine = this.edges.some(e => e.target === clicked.id && e.owner === this.currentPlayer);
                if(alreadyMine) { this.notify(this.t('notify_owned'), "var(--neon-secondary)"); return; }
            } else {
                const reachable = this.getReachableNodes(this.currentPlayer.nodeId);
                const myEdges = this.edges.filter(e => e.owner === this.currentPlayer);
                
                if (this.partyIndex === 0 && myEdges.length === 0) {
                    const deg = this.getNodeDegree(clicked.id);
                    if (deg > 1) { this.notify(this.t('notify_deg1'), "red"); return; }
                }

                if (clicked.type === 'prof') {
                    const sorted = [...this.players].sort((a,b) => b.score - a.score);
                    const rank = sorted.indexOf(this.currentPlayer);
                    if (rank < Math.floor(this.players.length / 2)) { this.notify(this.t('notify_prof_rej'), "red"); return; }
                } else {
                    const degree = this.getNodeDegree(clicked.id);
                    const mainComp = this.getMainComponent();
                    const isIsolatedOrSmall = (degree <= 1) || (!mainComp.has(clicked.id));
                    const isTutorial = (this.partyIndex === 0 && myEdges.length === 0);
                    const isHawaiian = (this.partyIndex === 4);
                    
                    if (!isTutorial && !isHawaiian && !isIsolatedOrSmall && !reachable.has(clicked.id)) {
                        this.notify(this.t('notify_too_far'), "#ffaa00"); 
                        return; 
                    }
                }
                const ownerEdge = this.edges.find(e => e.target === clicked.id && e.owner && e.owner !== this.currentPlayer);
                if (ownerEdge) {
                     const victimEdges = this.edges.filter(e => e.owner === ownerEdge.owner).length;
                     if (victimEdges <= 1) { this.notify(this.t('notify_no_solo'), "red"); return; }
                }
            }
            this.targetNode = clicked;
            this.updateControlDeck();
        }
    },
    updateControlDeck() {
        if (!this.targetNode) return;
        document.getElementById('target-name').innerText = this.targetNode.name.toUpperCase();
        document.getElementById('btn-roll').disabled = false;
        const probs = this.calcProb();
        
        if(probs.isTutorial) {
             document.getElementById('prob-disp').innerText = "100%";
             document.getElementById('target-sub').innerText = this.t('first_move');
             document.querySelectorAll('.calc-val').forEach(el => el.innerText = "N/A");
        } else {
            document.getElementById('prob-disp').innerText = probs.total + "%";
            document.getElementById('c-base').innerText = probs.base + "%";
            document.getElementById('c-diff').innerText = probs.diff + "%";
            
            // --- FIX CAOS SIGN ---
            // probs.chaos ja ve negatiu si Ã©s penalitzaciÃ³ (fmesta) o positiu si ajuda (normal)
            const chaosVal = probs.chaos;
            const sign = chaosVal >= 0 ? "+" : ""; // El negatiu ja el porta el nÃºmero
            const chaosEl = document.getElementById('c-chaos');
            chaosEl.innerText = sign + chaosVal + "%";
            chaosEl.className = chaosVal >= 0 ? "calc-val pos" : "calc-val neg";

            document.getElementById('c-boost').innerText = "+" + probs.boost + "%";
            
            let sub = this.t('cost_turn');
            if (this.isFMEstaMode) sub = `POPULARITAT: ${this.targetNode.coolness}`;
            else {
                const owner = this.edges.find(e => e.target === this.targetNode.id && e.owner && e.owner !== this.currentPlayer);
                if(owner) sub = `${this.t('steal_from')} ${owner.owner.name.toUpperCase()}`;
            }
            document.getElementById('target-sub').innerText = sub;
        }
    },
    buyBoost(type) {
        if(this.processing) return;
        const cost = this.currentPlayer.hasGrant ? (type==='beer'?1:3) : (type==='beer'?2:5);
        if (this.currentPlayer.budget >= cost) {
            this.currentPlayer.budget -= cost; this.currentBoost += (type==='beer'?10:25);
            this.updateControlDeck(); this.updateUI();
        }
    },
    calcProb() {
        if (this.isFMEstaMode) {
            let base = 80;
            let diff = this.targetNode.coolness; 
            let penalty = this.currentPlayer.drunkenness * 10;
            let total = base - diff - penalty + this.currentBoost;
            // Return negative chaos (penalty) so display logic handles signs correctly
            return { total: Math.max(5, Math.min(95, Math.floor(total))), base: base, diff: -diff, chaos: -penalty, boost: this.currentBoost, isTutorial: false };
        }

        const myEdgeCount = this.edges.filter(e => e.owner === this.currentPlayer).length;
        if (this.partyIndex === 0 && myEdgeCount === 0) return { total: 100, base: 100, diff: 0, chaos: 0, boost: 0, isTutorial: true };
        
        let base = 40;
        if (this.edges.find(e => e.target === this.targetNode.id && e.owner === this.currentPlayer)) base += 30;
        
        let diff = this.getNodeDegree(this.targetNode.id) * 5;
        if(this.targetNode.type === 'prof') diff = 30;
        if(this.targetNode.isGolden) diff += 15;

        let chaosBonus = Math.floor(this.chaos * 0.5);
        let total = base - diff + chaosBonus + this.currentBoost;
        return { total: Math.max(5, Math.min(95, Math.floor(total))), base: base, diff: -diff, chaos: chaosBonus, boost: this.currentBoost, isTutorial: false };
    },

    startSequence() {
        if (this.processing) return;
        this.processing = true;
        document.getElementById('btn-roll').disabled = true;
        document.getElementById('btn-pass').disabled = true;
        document.getElementById('btn-beer').disabled = true;
        document.getElementById('btn-shot').disabled = true;

        const probs = this.calcProb();
        const isSuccess = probs.isTutorial || (Math.random() * 100 <= probs.total);
        
        const overlay = document.getElementById('drama-overlay');
        const content = document.getElementById('drama-content');
        const flavor = document.getElementById('drama-flavor');
        const vs = document.getElementById('drama-versus');
        const bar = document.getElementById('drama-loader-bar');
        const resText = document.getElementById('drama-result-text');

        overlay.style.display = 'flex'; content.style.opacity = 1;
        resText.style.opacity = 0; resText.style.transform = 'scale(0)';
        const ph = TEXTS[this.lang].phrases;
        flavor.innerText = ph[Math.floor(Math.random() * ph.length)].toUpperCase();
        bar.style.width = "0%";

        const owner = this.edges.find(e => e.target === this.targetNode.id && e.owner && e.owner !== this.currentPlayer);
        vs.innerText = owner && !this.isFMEstaMode ? `${this.currentPlayer.name} VS ${owner.owner.name}` : `${this.currentPlayer.name} >> ${this.targetNode.name}`;

        let progress = 0;
        const interval = setInterval(() => {
            progress += 5; bar.style.width = progress + "%";
            if (progress >= 100) {
                clearInterval(interval);
                content.style.opacity = 0;
                setTimeout(() => {
                    resText.innerText = isSuccess ? this.t('success') : this.t('rejected');
                    resText.style.color = isSuccess ? "var(--neon-secondary)" : "#ff0055";
                    resText.style.opacity = 1; resText.style.transform = 'scale(1)';
                    setTimeout(() => { overlay.style.display = 'none'; this.finalizeMove(isSuccess); }, 1000);
                }, 200);
            }
        }, 20);
    },

    finalizeMove(isSuccess) {
        if(isSuccess) {
            if (!this.isFMEstaMode) {
                this.edges = this.edges.filter(e => !(e.target === this.targetNode.id && e.owner));
                this.currentPlayer.turnsThisParty++;
            } else {
                this.fmestaScores[this.currentPlayer.id]++;
                this.currentPlayer.drunkenness++; 
                this.currentPlayer.streak++;
                this.targetNode.coolness += 5;
                this.notify(`${this.targetNode.name} ${this.t('notify_hype')}`, "gold");
                if(this.partyIndex === 3) this.recalcScores(); 
            }
            this.edges.push(new Edge(this.currentPlayer.nodeId, this.targetNode.id, this.currentPlayer));
            if(this.targetNode.type === 'prof') this.currentPlayer.hasGrant = true;
            this.log(`${this.currentPlayer.name} ${this.t('log_conn')} ${this.targetNode.name}`);
            
            if (!this.isFMEstaMode) {
                if(this.currentPlayer.turnsThisParty < CONFIG.maxTurnsPerParty) this.queue.push(this.currentPlayer.id);
            } 
            this.detectCliques(); this.recalcScores();
        } else {
            this.log(`${this.currentPlayer.name} ${this.t('log_rej')} ${this.targetNode.name}`);
            if (this.isFMEstaMode) this.queue.shift(); 
            else this.currentPlayer.turnsThisParty = 999; 
        }
        this.nextTurn();
    },

    passTurn() { 
        if(this.processing) return;
        this.processing = true;
        if (this.isFMEstaMode) this.queue.shift(); 
        else this.currentPlayer.turnsThisParty = 999; 
        this.log(`${this.currentPlayer.name} ${this.t('log_pass')}`); 
        this.nextTurn(); 
    },

    recalcScores() {
        this.players.forEach(p => { p.score = p.fixedPoints; });
        this.edges.forEach(e => { 
            if(e.owner && !e.hidden) { 
                let target = this.nodes.find(n => n.id === e.target);
                if (target) e.owner.score += target.coolness; 
            } 
        });
        if (!this.isFMEstaMode) {
            this.players.forEach(p => {
                const pNode = this.nodes[p.nodeId];
                const tris = this.cliques.filter(c => c.includes(pNode)).length;
                p.score += (tris * 15);
            });
        }
        this.players.forEach(p => { if(p.hasGrant) p.score = Math.floor(p.score * 1.2); });
        this.updateUI();
    },

    endParty() {
        this.processing = true;
        if (this.isFMEstaMode) {
            this.endFMEstaMode();
        } else {
            this.players.forEach(p => {
                const goldenEdges = this.edges.filter(e => e.owner === p && this.nodes[e.target].isGolden);
                if (goldenEdges.length > 0) {
                    p.fixedPoints += (goldenEdges.length * 20);
                    this.notify(`${p.name} +${goldenEdges.length * 20} PTS (${this.t('notify_gold')})`, "gold");
                }
            });
        }
        this.recalcScores(); 
        
        if (!this.isFMEstaMode && this.partyIndex < 4) {
            const students = this.nodes.filter(n => n.type === 'student');
            for(let i=0; i<5; i++) {
                const a = students[Math.floor(Math.random()*students.length)];
                const b = students[Math.floor(Math.random()*students.length)];
                if(a!==b) this.edges.push(new Edge(a.id, b.id));
            }
        }
        if(this.partyIndex < CONFIG.parties.length - 1) setTimeout(() => this.startParty(this.partyIndex + 1), 3000);
        else this.triggerCredits();
    },

    saveScreenshot() {
        const allX = this.nodes.map(n => n.x); const allY = this.nodes.map(n => n.y);
        const minX = Math.min(...allX) - 100; const maxX = Math.max(...allX) + 100;
        const minY = Math.min(...allY) - 100; const maxY = Math.max(...allY) + 100;
        const graphW = maxX - minX; const graphH = maxY - minY;
        this.camera.x = minX + graphW/2 - this.width/2;
        this.camera.y = minY + graphH/2 - this.height/2;
        const zoomX = this.width / graphW; const zoomY = this.height / graphH;
        this.camera.zoom = Math.min(zoomX, zoomY) * 0.9; 
        setTimeout(() => {
            this.draw(); 
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = this.canvas.width; tempCanvas.height = this.canvas.height;
            const tCtx = tempCanvas.getContext('2d');
            tCtx.fillStyle = "#000"; tCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
            tCtx.drawImage(this.canvas, 0, 0);
            const link = document.createElement('a');
            link.download = 'final_graph_party.png'; link.href = tempCanvas.toDataURL(); link.click();
        }, 500);
    },

    triggerCredits() {
        this.players.forEach(p => { p.score = Math.floor(p.score * p.fmeMultiplier); });
        this.updateUI();
        const overlay = document.getElementById('credits-overlay');
        const content = document.getElementById('credits-content');
        const winnerDisplay = document.getElementById('winner-display');
        const winnerName = document.getElementById('winner-name');
        
        overlay.style.display = 'flex';
        let html = "";
        [...this.players].sort((a,b)=>b.score - a.score).forEach((p, i) => {
            html += `<div class="credit-role">${this.t('rank')} ${i+1} - ${p.score} PTS</div><div class="credit-name" style="color:${p.color}">${p.name} ${p.fmeMultiplier>1?'(x1.5)':''}</div>`;
        });
        content.innerHTML = html;
        const winner = [...this.players].sort((a,b)=>b.score - a.score)[0];
        setTimeout(() => {
            content.style.display = 'none'; winnerDisplay.style.display = 'flex';
            winnerName.innerText = winner.name; winnerName.style.color = winner.color;
            this.saveScreenshot();
        }, 15000); 
    },

    detectCliques() {
        this.cliques = [];
        for(let i=0; i<this.nodes.length; i++) { for(let j=i+1; j<this.nodes.length; j++) { for(let k=j+1; k<this.nodes.length; k++) {
            if(this.nodes[i].hidden || this.nodes[j].hidden || this.nodes[k].hidden) continue;
            const a = this.nodes[i].id, b = this.nodes[j].id, c = this.nodes[k].id;
            const ab = this.edges.some(e => !e.hidden && ((e.source===a && e.target===b) || (e.source===b && e.target===a)));
            const bc = this.edges.some(e => !e.hidden && ((e.source===b && e.target===c) || (e.source===c && e.target===b)));
            const ca = this.edges.some(e => !e.hidden && ((e.source===c && e.target===a) || (e.source===a && e.target===c)));
            if(ab && bc && ca) this.cliques.push([this.nodes[i], this.nodes[j], this.nodes[k]]);
        }}}
    },
    getNodeDegree(id) { return this.edges.filter(e => !e.hidden && (e.source === id || e.target === id)).length; },
    getReachableNodes(start) {
        let q = [[start, 0]], visited = new Set(), res = new Set();
        while(q.length) {
            let [c, d] = q.shift(); visited.add(c);
            if(d>0 && d<=3) res.add(c); if(d>=3) continue;
            this.edges.forEach(e => { 
                if(e.hidden) return;
                let n = (e.source===c?e.target:(e.target===c?e.source:null)); 
                if(n!==null && !visited.has(n)) q.push([n, d+1]); 
            });
        }
        return res;
    },
    notify(m, c="#fff") { const el=document.getElementById('notification'); el.innerText=m; el.style.color=c; el.style.opacity=1; setTimeout(()=>el.style.opacity=0, 2000); },
    log(m) { document.getElementById('log').insertAdjacentHTML('afterbegin', `<div>> ${m}</div>`); },

    updateUI() {
        const pl = document.getElementById('player-list'); pl.innerHTML='';
        [...this.players].sort((a,b)=>b.score-a.score).forEach(p => {
            pl.innerHTML += `<div class="card ${this.currentPlayer===p?'active':''}">
                <div style="color:${p.color};font-weight:bold">${p.name} ${p.hasGrant?'ðŸŽ“':''} ${p.fmeMultiplier>1?'â˜…':''}</div>
                <div style="display:flex;justify-content:space-between"><span>${p.score}</span><span style="color:var(--neon-secondary)">â‚¬${p.budget}</span></div>
            </div>`;
        });
        const ql = document.getElementById('queue-list'); ql.innerHTML='';
        if (this.isFMEstaMode) {
             ql.innerHTML = `<div style="color:var(--neon-primary)">${this.t('mode_time')}</div>`;
             this.queue.forEach((pid, i) => {
                 const p = this.players.find(x=>x.id===pid);
                 ql.innerHTML += `<div style="padding:2px;${i===0?'color:#fff;font-weight:bold':''}">${i+1}. ${p.name} (${this.t('streak')}: ${p.streak})</div>`;
             });
        } else {
            this.queue.forEach((pid, i) => {
                const p = this.players.find(x=>x.id===pid);
                ql.innerHTML += `<div style="border-bottom:1px solid #333;padding:4px;display:flex;justify-content:space-between">
                    <span style="${i===0?'color:var(--neon-secondary)':''}">${i+1}. ${p.name}</span><span>${p.turnsThisParty+1}/3</span></div>`;
            });
        }
        
        if(this.currentPlayer && this.isFMEstaMode) {
             document.getElementById('chaos-bar').style.width = (this.currentPlayer.drunkenness * 10)+"%";
             document.getElementById('chaos-bar').style.background = "#ff0055";
        } else {
             document.getElementById('chaos-bar').style.width = this.chaos+"%";
             document.getElementById('chaos-bar').style.background = "var(--neon-secondary)";
        }
    },

    resize() { this.width = this.canvas.clientWidth; this.height = this.canvas.clientHeight; this.canvas.width = this.width; this.canvas.height = this.height; },
    physics() {
        this.nodes.forEach(a => {
            if(a.hidden) return;
            let fx=0, fy=0;
            this.nodes.forEach(b => { 
                if(a===b || b.hidden) return; 
                let dx=a.x-b.x, dy=a.y-b.y, d2=dx*dx+dy*dy; 
                let f=1500/(d2+10); fx+=dx*f; fy+=dy*f; 
            });
            this.edges.forEach(e => { 
                if(e.hidden) return; if(!e.source || !e.target) return;
                if(e.source===a.id||e.target===a.id) { 
                    let targetId = e.source===a.id?e.target:e.source;
                    let b = this.nodes.find(n=>n.id === targetId);
                    if(b) { let dx=b.x-a.x, dy=b.y-a.y; fx+=dx*0.003; fy+=dy*0.003; }
                } 
            });
            fx -= a.x*0.008; fy -= a.y*0.008; 
            a.vx=(a.vx+fx)*0.9; a.vy=(a.vy+fy)*0.9; a.x+=a.vx; a.y+=a.vy;
        });
    },
    draw() {
        const ctx = this.ctx; ctx.clearRect(0,0,this.width,this.height); ctx.save();
        ctx.translate(this.width/2, this.height/2); ctx.scale(this.camera.zoom, this.camera.zoom); ctx.translate(-this.camera.x, -this.camera.y);
        
        if(!this.isFMEstaMode) {
            this.cliques.forEach(tri => {
                ctx.beginPath(); ctx.moveTo(tri[0].x, tri[0].y); ctx.lineTo(tri[1].x, tri[1].y); ctx.lineTo(tri[2].x, tri[2].y);
                ctx.fillStyle = 'rgba(255, 215, 0, 0.15)'; ctx.fill();
            });
        }
        this.edges.forEach(e => {
            if(e.hidden) return;
            const s = this.nodes.find(n => n.id === e.source);
            const t = this.nodes.find(n => n.id === e.target);
            if(!s || !t) return;
            ctx.beginPath(); ctx.moveTo(s.x, s.y); ctx.lineTo(t.x, t.y);
            if(e.owner) { ctx.strokeStyle = e.owner.color; ctx.lineWidth = 2.5/this.camera.zoom; ctx.globalAlpha = 0.8;
            } else { ctx.strokeStyle = 'rgba(255, 255, 255, 0.25)'; ctx.lineWidth = 1.5/this.camera.zoom; ctx.globalAlpha = 1; }
            ctx.stroke(); ctx.globalAlpha = 1;
        });
        if(this.currentPlayer && this.targetNode) {
            const s = this.nodes[this.currentPlayer.nodeId];
            ctx.beginPath(); ctx.moveTo(s.x, s.y); ctx.lineTo(this.targetNode.x, this.targetNode.y);
            ctx.strokeStyle = '#fff'; ctx.lineWidth = 2/this.camera.zoom; ctx.setLineDash([10/this.camera.zoom, 10/this.camera.zoom]);
            ctx.stroke(); ctx.setLineDash([]);
        }
        this.nodes.forEach(n => {
            if(n.hidden) return;
            const drawRadius = n.radius / this.camera.zoom; ctx.beginPath(); ctx.arc(n.x, n.y, drawRadius, 0, Math.PI*2);
            if(n.type==='player') { const p = this.players.find(x=>x.nodeId===n.id); ctx.fillStyle=p.color; ctx.shadowBlur=15; ctx.shadowColor=p.color; }
            else if(n.type==='prof') { ctx.fillStyle='#f00'; ctx.shadowBlur=10; ctx.shadowColor='#f00'; }
            else { 
                ctx.fillStyle='#444'; ctx.shadowBlur=0; 
                if (n.isGolden) { ctx.fillStyle='#ffd700'; ctx.shadowBlur=20; ctx.shadowColor='#ffd700'; }
                if (n.isTemporary) { ctx.fillStyle='#eee'; ctx.shadowBlur=5; ctx.shadowColor='#fff'; }
                if(this.currentPlayer && !this.isFMEstaMode) {
                    const reach = this.getReachableNodes(this.currentPlayer.nodeId);
                    const degree = this.getNodeDegree(n.id);
                    const mainComp = this.getMainComponent();
                    const isIsolated = degree <= 1 || !mainComp.has(n.id);
                    const isHawaiian = (this.partyIndex === 4);
                    if(isHawaiian || isIsolated || reach.has(n.id)) { if(!n.isGolden && !n.isTemporary) ctx.fillStyle='#888'; }
                }
            }
            if(this.targetNode===n) { ctx.strokeStyle='#fff'; ctx.lineWidth=3/this.camera.zoom; ctx.stroke(); }
            ctx.fill(); ctx.shadowBlur=0;
            if (n.type === 'player') { const p = this.players.find(x=>x.nodeId===n.id); ctx.font = `bold ${16/this.camera.zoom}px 'Roboto Mono'`; ctx.fillStyle = p.color; }
            else { ctx.font = `${10/this.camera.zoom}px 'Roboto Mono'`; ctx.fillStyle = '#fff'; }
            ctx.textAlign='center'; ctx.fillText(n.name, n.x, n.y - drawRadius - (5/this.camera.zoom));
            if(this.isFMEstaMode && n.isTemporary) { ctx.font = `${8/this.camera.zoom}px 'Roboto Mono'`; ctx.fillText(n.coolness, n.x, n.y + 5); }
        });
        ctx.restore();
    },
    loop() { this.physics(); this.draw(); requestAnimationFrame(()=>this.loop()); }
};

window.addEventListener('resize', () => game.resize());
window.addEventListener('wheel', e => { e.preventDefault(); game.camera.zoom *= e.deltaY > 0 ? 0.9 : 1.1; });
const c = document.getElementById('game-container');
c.addEventListener('mousedown', e => { game.camera.isDragging=true; game.camera.lastX=e.clientX; game.camera.lastY=e.clientY; });
window.addEventListener('mouseup', e => {
    if(game.camera.isDragging && Math.abs(e.clientX-game.camera.lastX)<5 && Math.abs(e.clientY-game.camera.lastY)<5) {
        const r = game.canvas.getBoundingClientRect(); game.handleInput(e.clientX-r.left, e.clientY-r.top);
    }
    game.camera.isDragging=false;
});
window.addEventListener('mousemove', e => {
    if(game.camera.isDragging) {
        game.camera.x -= (e.clientX-game.camera.lastX)/game.camera.zoom;
        game.camera.y -= (e.clientY-game.camera.lastY)/game.camera.zoom;
        game.camera.lastX=e.clientX; game.camera.lastY=e.clientY;
    }
});

// Init Default Text
game.updateTexts();
</script>
</body>
</html>